from .base_player import BasePlayer
from evolution.selection import FitnessWeightedSelector


class Population:
    """Population of (subclasses of) BasePlayers."""

    def __init__(self, size: int, players: list[BasePlayer], gen: int = 1) -> None:
        self.size = size
        self.players = players
        self.current_generation = gen
    
    @property
    def average_fitness(self) -> float:
        return (sum(player.fitness for player in self.players) / float(len(self.players)))

    @average_fitness.setter
    def average_fitness(self, value) -> None:
        raise Exception('Cannot set average fitness. This is a read-only property.')
    
    @property
    def champ(self) -> BasePlayer:
        return max(self.players, key = lambda player: player.fitness)

    @champ.setter
    def champ(self, value) -> None:
        raise Exception('Cannot set the champ. This is a read-only property.')

    def cull(self, percentage: float) -> None:
        """Remove all but top percentage of players with highest fitness."""

        self.players.sort(key = lambda player: player.fitness, reverse=True)
        if (num_left := int(self.size * percentage)) <= 1:
            raise Exception('Parent percentage is too low or the population is not large enough; there must be at least 2 parents.')
        self.players = self.players[:num_left]

    def repopulate(self, mutation_type: str, mutation_rate: float) -> None:
        """Add players to self.players until it has size self.size.
        
        Players are generated by crossing over two unique parents that are already in the population and then mutating the results.
        """

        self.current_generation += 1
        
        parents = Selector(self.players[:])
        while len(self.players) < self.size:

            #get 2 unique parents
            parent1
