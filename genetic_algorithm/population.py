import os

import numpy as np

from .base_player import BasePlayer
from evolution.selection import fitness_weighted_selection
from evolution.crossover import one_point_crossover, uniform_crossover, crossover_by_name
from evolution.mutation import gaussian_mutation, uniform_mutation, mutation_by_name


class Population:
    """Population of (subclasses of) BasePlayers."""

    def __init__(self, size: int, players: list[BasePlayer], gen: int = 1) -> None:
        self.size = size
        self.players = players
        self.current_generation = gen
    
    @property
    def average_fitness(self) -> float:
        return (sum(player.fitness for player in self.players) / float(len(self.players)))

    @average_fitness.setter
    def average_fitness(self, value) -> None:
        raise Exception('Cannot set average fitness. This is a read-only property.')
    
    @property
    def champ(self) -> BasePlayer:
        return max(self.players, key = lambda player: player.fitness)

    @champ.setter
    def champ(self, value) -> None:
        raise Exception('Cannot set the champ. This is a read-only property.')

    def cull(self, percentage: float) -> None:
        """Remove all but top percentage of players with highest fitness."""

        self.players.sort(key = lambda player: player.fitness, reverse=True)
        if (num_left := int(self.size * percentage)) <= 1:
            raise Exception('Parent percentage is too low or the population is not large enough; there must be at least 2 parents.')
        self.players = self.players[:num_left]

    def repopulate(self, crossover_type: str, mutation_type: str, mutation_rate: float) -> None:
        """Add players to self.players until it has size self.size.
        
        Players are generated by crossing over two unique parents that are already in the population and then mutating the results.
        """

        crossover = crossover_by_name(crossover_type)
        mutate = mutation_by_name(mutation_type)
        self.current_generation += 1
        
        parents = self.players[:]
        while len(self.players) < self.size:

            [parent1, parent2] = fitness_weighted_selection(parents)
            offspring1, offspring2 = parent1.empty_clone(), parent2.empty_clone()
            offspring1.genome, offspring2.genome = crossover(parent1.genome, parent2.genome, self.current_generation)
            offspring1.genome, offspring2.genome = mutate(offspring1.genome, mutation_rate), mutate(offspring2.genome, mutation_rate)
            self.players.extend([offspring1, offspring2])
            
        if len(self.players) == self.size + 1: self.players.pop()   #adding 2 at a time can cause us to add one too many

    def save(self, folder_name: str) -> None:
        """Save population stats and players' genomes.
        
        Designed to be done after a cull so that a new population can be repopulated from the save and continue evolution.
        """

        #check folder exists, create if it doesn't
        if not os.path.exists(folder_name):
            os.makedirs(folder_name)

        #clear the folder
        for file in os.listdir(folder_name):
            os.remove(f'{folder_name}/{file}')

        #save a dictionary of stats
        savez_dict = dict()
        savez_dict['size'] = self.size
        savez_dict['current_generation'] = self.current_generation
        savez_dict['fitness'] = [player.fitness for player in self.players]
        np.savez(f'{folder_name}/stats', **savez_dict)

        #save the genomes
        for i, player in enumerate(self.players):
            player.genome.save(i, folder_name)